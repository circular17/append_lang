// "append" language examples
var a/b = 5e10; c int = () ?? 7; d int
var number int | float | decimal = 5.4
var point #vec float*float = #vec (12.5, 8)
type TaggedPoint = #point {| x float, y float |}
var pointStruct TaggedPoint = {| x: 3, y: 45.4 |}
global fun p1 TaggedPoint "+" p2 TaggedPoint
    => #point {| x: p1.x + p2.x, y: p1.y + p2.y |}
let {| x: myX, y: myY, coords: (a, b, c) |} = pointStruct
var {| x, y |} = pointStruct <| x: 4
let xOnly = pointStruct <| !y
pointStruct.y := 6
let problematic str = "this {a}"
var anything any = "hello"   // this will be inferred
var functionVar int->int->int = => $x + $y

trait Concatenable { // "Self" is the type for which the trait is checked
    fun left Self "++" right Self: Self
}

trait Countable {
    prop count int
}

trait StringLike {
    ...Concatenable,
    fun a Self "substring" from int; to int: Self
}

// the following function only works on types that are both concatenable and countable
fun a Concatenable & Countable "*" count int do
    count < 0 ?
        #err "Expecting positive repetition"
    else
        count
        | 0 -> ""
        | 1 -> a
        other
            a ++ a * (count - 1)
end

// function "someStuff" without parameters, return void or an error
fun () "someStuff": () | #err any do
    () someOperation
    mut a add "world"
    a[5] := "hello"
    mut a del "goodbye"
    () optionalStuff \ drop   // ignore the errors
    "Processing successful" print
when // handle implicit return values different from #done
    | #note @message -> resume   // opting out
    | #notNecessary @message -> "This processing is not necessary so we'll stop" print
    | #warning @message -> {
        "We have been warned but we will continue anyway: {message}" print
        resume
    }
    | #detect @message -> {
        "Object detected while probing: {message}" print
        resume
    }
end

fun mut x "inc" => x += 1
mut a inc

let square = :x => x * x
var subroutine ()->()
var linkedList ::int = 12::34::67::<>
linkedList head
| #none -> "linked list is empty" print
| #ok @value -> "linked list starts with {value}" print

fun list ::any "length": int
    | head::tail -> 1 + (tail length)
    | <> -> 0

var optionalList [int]? = ()
optionalList = [1, 2, 3]
mut optionalList ins (-12); 0
mut optionalList del 1+..2 // range from 1, 2 elements long

var setOfStr set{str} = set{"a", "b", "c"}
let onlyAB = setOfStr but "c"

mut setOfStr add "four"
| #done -> "four added" print
| #dup -> "four already in set" print

mut setOfStr del "four"
| #done -> "four deleted" print
| #none -> "four not found" print

var dictionary #lookup dict{int -> str} = dict{5 -> "five", 7 -> "seven"}
let ZERO = 0. let ONE int = 1
type circleF = #circle float
let h = f >> g
let multi = 2 add 3 squared; 4 cubed
//let piped = 2 add 3 \ squared

/* here is a function that
 returns a fixed number */
fun () "three" => 3

fun x "add" y int: int => x + y

// matching

fun shape "area"
    | #rectangle(@width float, @height float) -> width * height
    | #circle(inputData computeRadius) -> knownArea
    | #circle @radius float -> radius ^ 2 * 3.14
    | _ -> 0    // Default or unrecognized shape

// conditions inside a function

fun size any^3 "cubeVolume" do
    let (x, y, z) = size
    y = 0 ?
        0
    else {
        let surface = x * y
        surface * z
    }
when _ -> #fail // hide error detail
end

// doing things on a tuple
(2, 3) reduce (+)

(2, 3) case (@x, @y) -> x + y
(2, 3)
| (@x, @y) -> x + y

(2, 3) :point {
    let (x, y) = point
    return x + y
}

// iterating
0..<10 each :j {
    "j = {j}" print
}

0..=9 each => "n = {$n}" print

var i = 0
while i < 10 {
    "hello" print
    i += 1
}

// function "has"
fun list "has" element =>
    list index element
    | #none -> no
    other yes

var _locales dict{(str | ()) -> any} = dict{ }
state fun identifier "locale" do
    _locales has identifier ?
        _locales[identifier]
    else
    {
        let instance JSObject = JS--Intl--Locale new identifier
        _locales[identifier] := instance
        instance
    }
end

let fixed = {| size: 15, frac: 0, group: yes, locale: (), var temp: "" |}
fun value float "as" format do

end

fixed wise {
    "{.size} {.frac} {.group}" print
}

fun text "right" width do
    let toPad = width - text len
    toPad > 0 ?
        " " repeat toPad ++ text
    else
        text
end

let F = fixed <| locale: "fr-FR" locale
let amount = 2142.20
"Your current balance is {amount as F} viewers" print
"{amount1 as F \ right 15}" print
"{amount2 as F \ right 15}" print

fun n int "factorial" =>
    n < 0 ? #err "Expecting positive number"
    else
        n
        | 0, 1 -> 1
        other n * ((n - 1) factorial)

fun n int "factorial"
    | < 0 -> #err "Expecting positive number"
    | in 0..=1 -> 1
    other n * ((n - 1) factorial)

fun list [[@T]] "flat": [@T] =>
    list reduce (++)

1..=3 {*} 1..=3 // all 9 positions in a 3x3 square

[[1, 2, 3], [4, 5, 6]] flat // 1..=6 list

var _localeCount = 0 // private static variable of module

record Locale {|
    const identifier str? // voidable and readonly because not var
    tag any: () // freely accessible, need to copy the array to modify, with default value

    init _instance JS--Intl--Locale // private and readonly
    prop calendar str => _instance.calendar // readonly via accessor

    var _positive int: 0 // private read/write, with default value
    state prop positive int // public read/write via accessor
        => _positive
        set => $v >= 0 ? _positive := $v

    new | #err str
        // identifier will need to be set in initialization record expression
        _instance := JS--Intl--Locale new identifier
        _localeCount += 1
    end
|}

// functional paradigm: not inside objects
fun locale Locale "showInfo" do
    "This locale is identified by: {locale.identifier}" print
end

let defaultLocale = Locale {| identifier: () |} // tag has default value

record FrenchLocale {|
    ...Locale,
    base identifier = "fr-FR"
    var croissants int
    new
        croissants := 3 + 5 random
    end
|}

// replace function for specific locale
fun locale FrenchLocale "showInfo" do
    locale wise {
        "This locale is identified by: {.identifier}" print
        "There are {.croissants} croissants" print
    }
end

fun mut locale "buyCroissant" => locale.croissants += 1 // works with any locale with croissants

async sub urls "gatherData" =>
  urls map => $u fetch defer \ wantAll defer // defer to not wait for result
  | #ok dataList -> dataList processData
  | #err e -> "There was an error in one or more fetch operations: {e}" log

// async implicit await
let entries = "phonebook.txt" readFile

enum n int "getNumbersSeq": int do
    var i int = 0
    while i < n {
        yield i
        i += 1
    }
end

let numbersEnum enum->int = enum: int {
    yield 1
    yield 2
    yield 3
    yield 4
}

fun lst enum->@T "tally": dict{@T -> int} do
    var counts dict{T -> int} = dict{}
    lst each :x => counts[x] = (counts[x] ?? 0) + 1 // supposing that ?? can be applied to (#ok T | #none)
    counts
end

fun lst enum->@T "each" action @T->any: #done | any do
    iter () lst.fetch // could be implicit await, could be io
    | #done -> break
    | #ok @item -> {
        item action
        | (), #done, #ok @subItem -> next
        | @subError -> return error
    }
    | @error -> return error
    #done
end

fun keys set{@T} "associate" f @T->@U : dict{@T -> @U} do
    var result dict{T -> U} = dict{}
    keys each :k => result[k] = k f
    result
end

fun ab (enum->@T)^2 "tally": dict{@T -> int*int} do
    let (aCounts, bCounts) = ab each tally
    let allKeys = aCounts.keys {+} bCounts.keys
    allKeys associate :k => (aCounts[k] ?? 0, bCounts[k] ?? 0)
end

fun a enum->@T "listUnion" b enum->@T: [@T] do
    (a, b) tally \ flatMap :k T; v int*int
        => [k] * (v max)
end

fun a enum->@T "listDiff" b enum->@T: [@T] do
    let aCounts = a tally
    let bCounts = b tally

    aCounts flatMap :k T; v int =>
        [k] * ((v - (bCounts[k] ?? 0), 0) max)
end

fun a enum->@T "listInter" b enum->@T: [@T] do
    let aCounts = a tally
    let bCounts = b tally

    aCounts flatMap :k T; v int =>
        [k] * ((v, bCounts[k] ?? 0) min)
end

var myCounter = 0 // would be outside
state fun () "counter": int do
    myCounter += 1
end

// enum->@T
// {| state fun () "fetch": T? => ? |}
// async enum->@T
// {| async state fun () "fetch": T? => ? |}

fun n @T "getNumbersEnum": enum->@T =>
  {|
    var _current T: 0
    _last T: n
    state fun () "fetch" =>
      me._current < me._last ? {
        let result = _current
        _current += 1
        #ok result
      } else #done
    state fun () "close" => ()
  |}

var myEnum enum->int = 5 getNumbersEnum
iter () myEnum.get
    | #ok @i -> { "Number {i}" print. next }
    other break
() myEnum.close

// Range from low to high excluded
fun low @T "..<" high @T: enum->@T =>
  {|
    var _current T: low
    _high T: high
    state fun () "fetch" =>
      me._current < me._high ? {
        let result = _current
        _current += 1 // type T only need to handle "+ 1" and "<"
        #ok result
      } else #done
    state fun value "has" =>
      value >= low & value < high
  |}

record Console {|
    sub data any "log" => ?
|}

record JSConsole {|
    ...Console
    sub data any "log" => data JS--Console.log
|}

fun message str "print" with Console
    => message Console.log

"Hello" print with JSConsole

do with JSConsole
    "Hello" print
end

fun fileName "readFile": str with io do
    // Reads a file, which is a side effect
end

enum filename "getLines": str with io do
    var file = filename openFile
    while file !eof
        yield file readLine
    file close
end