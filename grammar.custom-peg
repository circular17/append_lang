// grammar using a custom PEG format
// it needs to be preprocessed by grammar-preprocessor

/************* MODULE STRUCTURE *************/

module
    = __ s:moduleStatements __
        => #MODULE { statements: s }

moduleStatements // []
    = hd:moduleStatement tl:(statementSeparator s:moduleStatement => s)*
        { return hd::tl.flat() }
    / "" => []

statement
    = defs
    / vars
    / typeDefs
    / recordDef
    / fun
    / branch

moduleStatement // [] or leaf
    = statement
    / explicitModuleBlock

statementSeparator
    = _ d:"." " " _ => d
    / eol

defs // []
    = "let" _ hd:def tl:(_ ";" __ d:def => d)*
        => hd::tl

def
    = _ names:(names / deconstruct) _ type:type? _ "=" _ v:branch
        => #CONST_DEF { names, type, value: v }

vars // []
    = "var" _ hd:var tl:(_ ";" __ v:var => v)*
        => hd::tl

var
    = names:(names / deconstruct) _ "=" _ v:branch
        => #VAR_DEF { names, type: null, value: v }
    / names:(names / deconstruct) _ type:type _ v:("=" _ v:branch => v)?
        => #VAR_DEF { names, type, value: v }

names = i:identifiers => #NAMES { identifiers:i }

deconstruct
    = "(" __ hd:deconstructElement tl:(_ "," __ e:deconstructElement => e)* __ ")"
        => #DECONSTRUCT_TUPLE { elements: hd::tl }
    / "{|" __ hd:deconstructMember tl:(_ "," __ e:deconstructMember => e)* __ "|}"
        => #DECONSTRUCT_RECORD { elements: hd::tl }

deconstructMember
    = member:id value:(_ colon __ e:(deconstructElement / deconstruct) => e)?
        => #DECONSTRUCT_MEMBER { member, value }

deconstructElement
    = id:id => #DECONSTRUCT_NAME { name: id }
    / deconstruct

typeDefs // []
    = "type" _ hd:typeDef tl:(_ ";" __ t:typeDef => t)*
        => hd::tl

typeDef
    = _ name:id genericParams:genericParams _ "=" _ type:type
        => #TYPE_DEF {
            name,
            genericParams: genericParams,
            type
        }

genericParams
    = _ "of" __ "@" hd:id tl:(_ "/" __ "@" i:id => i)*
        => hd::tl
    / "" => []

recordDef
    = "record" _ n:namedRecType => n

explicitModuleBlock
    = "do" effects:effects? __ s:moduleStatements __ when:when? __ "end"
        => #CODE_BLOCK { statements: s, effects: effects ?? [], when }

when
    = "when" (eol _ pipe? _ / __) c:caseBody => c

/************* FUNCTION DEFINITION *************/

fun
    = f:funHeader _ body:funBody {
        f.body = body
        return f
    }

funHeader
    = isGlobal:isGlobal isAsync:isAsync purity:purity
    kind:funKind _ hd:funParam __ "\"" keywordName:$(keyword?) name:(id / overridableOp)? "\""
    tl:(__ p:params => p)? returnType:(_ colon __ t:type => t)?
    effects:(__ "with" _ e:identifiers => e)? {
        if (keywordName)
            error(`The keyword '${keywordName}' cannot be used as an identifier`)
        if (!name)
            error("The name of the function is not specified")
        return #FUN_DEF {
            isGlobal,
            isAsync,
            purity,
            kind,
            name,
            params: [hd].concat(tl ?? []),
            effects: effects ?? [],
            returnType
        }
    }

isGlobal
    = "global" _ => true
    / "" => false

isAsync
    = "async" _ => true
    / "" => false

funParam
    = mut:("mut" _)? names:identifiers type:(_ t:type => t)?
        => #FUN_PARAM_DEF { names, type, mutable: !!mut }
    / void
        => #FUN_PARAM_DEF {
            names:[""],
            type: #VOID_TYPE {}
        }

params // []
    = hd:funParam tl:(_ ";" __ p:funParam => p)*
        => hd::tl

funKind
    = "fun" / "sub" / "enum"

purity
    = p:"state" _ => p
    / "" => "pure"

funBody
    = __ "=>" __ v:branch => v
    / __ "=>" _ "?" => null
    / __ explicitFunBlock
    / case
    / keyword { error("Unexpected keyword") }

explicitFunBlock
    = "do" effects:effects? __ s:funStatements __ when:when? __ "end"
        => #CODE_BLOCK { statements: s, effects: effects ?? [], when }

funStatements // []
    = hd:funStatement tl:(statementSeparator s:funStatement => s)*
        { return hd::tl.flat() }
    / "" => []

funStatement // [] or leaf
    = statement
    / explicitFunBlock
    / return

return
    = "return" _ value:branch
        => #RETURN { value }
    / "yield" _ value:branch
            => #YIELD { value }
    / "resume" => #RESUME { }
    / "next" => #NEXT { }
    / "break" => #BREAK { }

/************* BRANCHING *************/

branch
    = optionWithPipe
    / loop

loop
    = "while" _ condition:valueExpr __ body:(branch / inlineBlock / return)
        => #WHILE { condition, body }
    / "iter" body:(branch / inlineBlock / return)
        => #ITER { body }

optionWithPipe
    = value:pipedExpr option:(ternary / case / wiseBlock)? {
        if (option) {
            option.key = value
            return option
        }
        else
            return value
    }

optionNoPipe
    = value:valueExpr option:(ternary / wiseBlock)? {
        if (option) {
            option.key = value
            return option
        }
        else
            return value
    }

wiseBlock
    = _ "wise" __ "{" __ statements:funStatements __ close:"}"? {
        if (!close)
            error("Expecting \")\" to close the 'wise' block")
        return #WISE_BLOCK {
            statements
        }
    }

ternary
    = __ "?" __ ifTrue:(branch / inlineBlock / return) ifFalse:(__ "else" __ v:(branch / inlineBlock / return) => v)?
        => #TERNARY { ifTrue, ifFalse }
case
    = _ ("case" __ pipe? _ / eol _ pipe _) c:caseBody => c

inlineBlock
    = "{" !(([-+&*^] / [><] "="? / "!=") "}") __ statements:funStatements __ "}"
        => #CODE_BLOCK { statements }

/************* PATTERN MATCHING *************/

caseBody
    = hd:caseOption tl:(__ pipe _ o:caseOption => o)*
    otherValue:(__ "other" __ value:(branch / inlineBlock / return) => value)? {
        var options = hd::tl
        if (otherValue)
            options.push(#CASE_OPTION {
                pattern: #CAPTURE { name: "_" },
                value: otherValue })
        return #CASE { options }
    }

caseOption
    = hd:pattern tl:(_ "," __ p:pattern => p)* __ "->" __ value:(branch / inlineBlock / return)
        => #CASE_OPTION { patterns: hd::tl, value }

pattern
    = taggedPattern
    / valueExpr

taggedPattern
    = tag:tag value:(_ pattern)?
        => #TAGGED_VALUE {
            tag,
            value: value ?? #VOID_VALUE { }
        }
    / linkedListPattern

linkedListPattern
    = head:untaggedPattern tail:(_ "::" __ t:linkedListPattern => t)* {
        if (tail)
            return #LINKED_LIST {
                head,
                tail
            }
        else
            return head
    }

untaggedPattern
    = capture
    / comparisonPattern
    / tuplePattern
    / recPattern
    / listPattern
    / setPattern
    / dictPattern

comparisonPattern
    = operator:(">" / ">=" / $("<" ![>|]) / "<=" / "in") _ value:aboveComparison

tuplePattern
    = "(" startEllipsis:(_ "...")? __ hd:pattern tl:(_ "," __ v:pattern => v)*
    endEllipsis:(_ "..." _)? close:(__ ")")? {
        if (!close) {
            if (tl.length > 0)
                error("Expecting \")\" to close the tuple")
            else
                error("Expecting matching \")\"")
        }
        return tl.length > 0
            ? #TUPLE { values: hd::tl, startEllipsis: !!startEllipsis, endEllipsis: !!endEllipsis  }
            : hd
        }

recPattern
    = "{|" _ ellipsis:("..." _)? "|}"
        => #REC_VALUE { members: [], ellipsis: !!ellipsis }
    / "{|" __ hd:recMemberPattern tl:(_ "," __ m:recMemberPattern => m)*
    ellipsis:(_ "..." _)? close:(__ "|}")? {
        if (!close) error("Expecting \"|\x7d\" to close the record")
        return #REC_VALUE { members: hd::tl, ellipsis: !!ellipsis }
    }

recMemberPattern
    = name:id _ colon __ value:pattern
        => #REC_MEMBER_VALUE { name, value }

listPattern
    = "[" _ ellipsis:("..." _)? "]"
        => #LIST { values: [], startEllipsis: false, endEllipsis: !!ellipsis }

    / "[" startEllipsis:(_ "...")? _ hd:pattern tl:(_ "," __ v:pattern => v)*
    endEllipsis:(_ "..." _)? close:(__ "]")? {
        if (!close) error("Expecting \"]\" to close the list")
        return tl.length > 0
            ? #LIST { values: hd::tl, startEllipsis: !!startEllipsis, endEllipsis: !!endEllipsis }
            : hd
    }

setPattern
    = "set" _ "{" _ ellipsis:("..." _)? "}"
        => #SET { values: [], ellipsis: !!ellipsis }

    / "set" _ "{" __ hd:pattern tl:(_ "," __ v:pattern => v)* __ ellipsis:("..." _)? close:"}"? {
        if (!close) error("Expecting \"\x7d\" to close the set")
        return tl.length > 0
            ? #SET { values: hd::tl, ellipsis: !!ellipsis }
            : hd
        }

dictPattern
    = "dict" _ "{" _ ellipsis:("..." _)? "}"
        => #DICT_VALUE { elements: [], ellipsis: !!ellipsis }

    / "dict" _ "{" __ hd:dictKeyPattern tl:(_ "," __ m:dictKeyPattern => m)
    __ ellipsis:("..." _)? close:"}"? {
        if (!close) error("Expecting \"\x7d\" to close the dictionary")
        return #DICT_VALUE { elements: hd::tl, ellipsis: !!ellipsis }
    }

dictKeyPattern
    = key:valueExpr _ "->" __ value:pattern
        => #DICT_KEY_VALUE { key, value }

capture
    = "@" id:id type:(_ t:tupleType => t)?
        => #CAPTURE {
            name: id,
            type: type ?? #ANY_TYPE { }
        }
    / id:"_" => #CAPTURE { name: id } // any value

/************* TYPE DEFINITIONS *************/

type = unionType

unionType
    = hd:taggedType tl:(_ pipe __ t:taggedType => t)* {
        return tl.length > 0
            ? #UNION_TYPE { params: hd::tl }
            : hd }

taggedType
    = tag:tag type:(_ t:taggedType => t)?
        => #TAGGED_TYPE {
            tag,
            type: type ?? #VOID_TYPE { }
        }
    / functionType

functionType
    = isAsync:isAsync purity:purity hd:recordMerge tl:(_ "->" __ t:recordMerge => t)* {
        return tl.length > 0
            ? #FUN_TYPE {
                isAsync,
                purity,
                params: hd::tl
            }
            : hd }

recordMerge
    = hd:tupleType tl:(_ "++" __ tupleType)* {
        return tl.length > 0
            ? #RECORD_MERGE { records: hd::tl }
            : hd
    }

tupleType
    = hd:tuplePowerType tl:(_ "*" __ t:tuplePowerType => t)* {
        return tl.length > 0
            ? #TUPLE_TYPE { types: hd::tl }
            : hd }
tuplePowerType
    = base:voidableType power:(_ powerOp __ i:integer => i)? {
        return power
            ? #TUPLE_POWER_TYPE { base, power }
            : base }
voidableType
    = nonVoidable:nonVoidableType isVoidable:"?"? {
        return isVoidable
            ? #VOIDABLE_TYPE { type: nonVoidable }
            : nonVoidable }
nonVoidableType
    = namedType
    / anyType
    / genericParamType
    / listType
    / linkedListType
    / enumType
    / setType
    / dictType
    / anonymousRecType
    / voidType
    / "(" __ t:type __ ")" => t

listType = "[" __ elementType:type __ "]" => #LIST_TYPE { type: elementType }
linkedListType = "::" _ elementType:type => #LINKED_LIST_TYPE { type: elementType }

enumType
    = isAsync:isAsync "enum" elementType:(_ "->" __ t:recordMerge => t)?
        => #ENUM_TYPE {
            isAsync,
            elementType: elementType ?? "any"
        }

setType = "set" _ "{" __ elementType:type __ "}" => #SET_TYPE { type: elementType }

dictType
    = "dict" _ "{" __ key:tupleType _ "->" __ value:tupleType __ "}"
        => #DICT_TYPE { key, value }

namedRecType
    = name:id genericParams:genericParams _ "{|" __
    hd:namedRecMemberType tl:((_ "," / eol) __ m:namedRecMemberType => m)* __ "|}"
        => #REC_TYPE {
            name,
            genericParams,
            members: hd::tl
        }
namedRecMemberType
    = namedRecInheritance
    / namedRecFieldType
    / propDef
    / fun
    / constructor

namedRecInheritance
    = "..." parent:namedType => #INHERITANCE { parent }

namedRecFieldType
    = modifier:namedRecFieldTypeModifier? names:(_ i:identifiers => i) type:(_ t:type => t)?
    defaultValue:(_ ":" __ value:valueExpr => value)? {
        if (!type && !defaultValue)
            error("The type or the value of the member must be specified")
        return #REC_MEMBER_TYPE { modifier, names, type, defaultValue }
    }
namedRecFieldTypeModifier
    = "const" / "base" / "init" / "var"

anonymousRecType
    = "{|" __ hd:anonymousRecMemberType tl:((_ "," / eol) __ m:anonymousRecMemberType => m)* __ "|}"
        => #REC_TYPE {
            name: null,
            genericParams: [],
            members: hd::tl
        }
anonymousRecMemberType
    = anonymousRecFieldType
    / propDef
    / fun

anonymousRecFieldType
    = modifier:anonymousRecFieldTypeModifier? _ names:identifiers _ type:type?
    defaultValue:(_ ":" __ value:valueExpr => value)? {
        if (!type && !defaultValue)
            error("The type or the value of the member must be specified")
        return #REC_MEMBER_TYPE { modifier, names, type, defaultValue }
    }
anonymousRecFieldTypeModifier
    = "const" / "var"

propDef
    = "prop" _ name:id _ type:type? __ purity:"state"? getter:getterBody setter:setter?
        => #PROP_DEF {
            name,
            purity: purity ?? "pure",
            type,
            getter,
            setter
        }
setter
    = __ "set" _ body:lambda => body
getterBody
    = "=>" __ v:branch => v
    / "{" __ s:funStatements __ "}"
        => #CODE_BLOCK { statements: s }

lambda
    = isAsync:isAsync purity:purity kind:(m:"sub" _ => m)? "=>" __ value:optionNoPipe
        => #FUN_DEF {
            isAsync,
            purity,
            kind: kind ?? "fun",
            name: null,
            params: tree.getLambdaVariables(value),
            body: value,
            returnType: null
        }
    / isAsync:isAsync purity:purity kind:("sub" / colon) _ params:params __ returnType:(colon _ t:type __ => t)? body:lambdaBody
        => #FUN_DEF {
             isAsync,
             purity,
             kind: kind === ":" ? "fun" : kind,
             name: null,
             params: params,
             body: body,
             returnType: returnType
         }
     / isAsync:isAsync purity:purity "enum" __ returnType:(colon _ t:type __ => t)? body:lambdaBody
        => #INLINE_ENUM {
            isAsync,
            purity,
            kind: "enum",
            body: body,
            returnType: returnType ?? "any"
        }

lambdaBody
    = "=>" __ v:optionNoPipe => v
    / "{" __ s:funStatements __ "}"
        => #CODE_BLOCK { statements: s }
    / case

constructor
    = isAsync:isAsync "new" returnType:(_ pipe _ t:type => t)? body:constructorBody
        => #FUN_DEF {
            isAsync,
            kind: "fun",
            name: "new",
            params: [],
            body,
            returnType
        }
constructorBody
    = __ s:funStatements __ when:when? __ "end"
        => #CODE_BLOCK { statements: s, when }

voidType = void => #VOID_TYPE {}

namedType = base:valueByName params:genericOrSpecializeParams? {
        if (params)
            return #SPECIALIZE_TYPE { base, params }
        else
            return base
    }
genericOrSpecializeParams
    = _ "of" __ hd:(genericParamType / valueByName) tl:(_ "/" __ t:(genericParamType / valueByName) => t)*
        => hd::tl

genericParamType = "@" id:id => #GENERIC_PARAM_TYPE { name: id }
anyType = "any" => #ANY_TYPE {}

/************* EXPRESSIONS *************/

pipedExpr
    = option:valueExpr pipeCall:(_ "\\" __ c:appendCall => c)? {
        if (pipeCall)
        {
            pipeCall.params.unshift(option)
            return pipeCall
        }
        else
            return option
    }

valueExpr = assignment

assignment
    = variable:withEffect assign:assignValue? {
        if (assign)
        {
            assign.variable = variable
            return assign
        }
        else
            return variable
    }

assignValue
    = _ op:assignmentOp __ value:branch
        => #ASSIGN { operator: op, value }

withEffect
    = value:default effects:effects? {
        if (effects)
            return #WITH_EFFECT { value, effects }
        else
            return value
    }

effects // []
    = _ "with" _ hd:default tl:(_ "," __ d:default => d)*
        => hd::tl

default = hd:disjunction tl:(__ "??" __ d:default => d)* {
        return tl.length > 0
            ? #DEFAULT_VALUE { values: hd::tl }
            : hd
    }

disjunction
    = hd:xor tl:(__ "or" __ o:xor => o)* {
        return tl.length > 0
            ? #DISJUNCTION { operands: hd::tl }
            : hd
        }
xor
    = hd:conjunction tl:(__ "xor" __ o:conjunction => o)* {
        return tl.length > 0
            ? #XOR { operands: hd::tl }
            : hd
        }
conjunction
    = hd:comparison tl:(__ "&" !"=" __ o:comparison => o)* {
        return tl.length > 0
            ? #CONJUNCTION { operands: hd::tl }
            : hd
        }

comparison
    = firstOperand:aboveComparison otherOperands:otherComparisonOperand* {
        return otherOperands.length > 0
            ? #COMPARISON {
                operands: [#COMPARISON_OPERAND { operator: null, value: firstOperand }].concat(otherOperands)
            }
            : firstOperand
        }
otherComparisonOperand
    = __ operator:comparisonOp __ operand:aboveComparison
        => #COMPARISON_OPERAND { operator, value: operand }

aboveComparison = setComparison

setComparison
    = firstOperand:aboveSetComparison otherOperands:otherSetComparisonOperand* {
        return otherOperands.length > 0
            ? #SET_COMPARISON {
                operands: [#SET_COMPARISON_OPERAND { operator: null, value: firstOperand }].concat(otherOperands)
            }
            : firstOperand
        }
otherSetComparisonOperand
    = _ operator:setComparisonOp __ operand:aboveSetComparison
        => #SET_COMPARISON_OPERAND { operator, value: operand }

aboveSetComparison = linkedList

linkedList
    = head:modifyRec tail:(__ "::" __ tl:linkedList => tl)? {
        if (tail)
            return #LINKED_LIST { head, tail }
        else
            return head
    }

modifyRec
    = set:concat changes:(__ "<|" _ hd:modifyMember tl:(__ "<|" c:modifyMember => c)* => hd::tl)* {
        if (changes.length > 0)
            return #MODIFY_REC { set, changes }
        else
            return set
    }

modifyMember
    = name:id _ colon __ value:valueExpr
        => #REC_MEMBER_VALUE { name, value }
    / "!" _ name:id
        => #REC_MEMBER_VALUE { name, value: null } // remove

concat
    = hd:addition tl:(__ concatOp __ other:addition => other)* {
        return tl.length > 0
            ? #CONCAT { operands: hd::tl }
            : hd
        }

addition
    = hd:firstTerm tl:otherTerm* {
        return tl.length > 0 || hd.sign !== "+"
            ? #ADDITION { terms: hd::tl }
            : hd.value
        }
firstTerm
    = sign:additiveOp? _ term:term
        => #TERM { sign:sign ?? "+", value:term }

otherTerm
    = _ sign:additiveOp __ term:term
        => #TERM { sign, value:term }

term = call

call
    = c:nestedCall {
        if (tree.isNodeOf(tree.MUTABLE_PARAM))
            error("Mutable keyword can only used to pass parameters")
        return c
    }

nestedCall
    = left:callParam appendCall:appendCall? {
        if (appendCall)
        {
            appendCall.params.unshift(left)
            return appendCall
        }
        else
            return left
    }

appendCall
    = _ fun:(multiplication / "new") defer:(_ "defer")? params:rightParams?
        => #CALL { fun, defer: !!defer, params: params ?? [] }

rightParams
    = _ hd:call tl:(_ ";" __ c:nestedCall => c)*
        => hd::tl

callParam
    = mut:"mut"? _ value:setDiff {
        if (mut)
            return #MUTABLE_PARAM { value }
        else
            return value
    }

setDiff
    = hd:setUnion tl:(__ "{-}" __ t:setUnion => t)* {
        if (tl.length > 0)
            return #SET_DIFF { sets: hd::tl }
        else
            return hd
    }

setUnion
    = hd:setInter tl:(__ "{+}" __ t:setInter => t)* {
          if (tl.length > 0)
              return #SET_UNION { sets: hd::tl }
          else
              return hd
      }

setInter
    = hd:cartesianProd tl:(__ "{&}" __ t:cartesianProd => t)* {
          if (tl.length > 0)
              return #SET_INTER { sets: hd::tl }
          else
              return hd
      }

cartesianProd
    = hd:range tl:(__ "{*}" __ r:range => r)* {
        if (tl.length > 0)
            return #CARTESIAN_PROD { sets: hd::tl }
        else
            return hd
    }

cartesianPower
    = base:range power:(_ "{^}" __ r:range => r)* {
        if (tl.length > 0)
            return #CARTESIAN_POWER { base, power }
        else
            return hd
    }

range
    = first:multiplication to:(_ op:rangeOp __ lastOrCount:multiplication)? {
        if (to)
            return #RANGE { first, lastOrCount: to.lastOrCount, op: to.op }
        else
            return first
    }

multiplication
    = hd:factor tl:otherFactor* {
        return tl.length > 0
            ? #MULTIPLICATION {
                factors: [#FACTOR { operator:"*", value:hd }].concat(tl)
            }
            : hd
        }
otherFactor
    = __ operator:multiplicativeOp __ factor:factor
        => #FACTOR { operator, value:factor }
factor
    = not
    / exponentiation;

not = notOp f:factor
    => #NOT { value:f }

exponentiation
    = base:indexing power:(_ powerOp __ p:indexing => p)? {
        return power
            ? #EXPONENTIATION { base, power }
            : base
        }

indexing
    = list:compose index:(_ "[" __ i:branch __ "]" => i)? {
        return index
            ? #INDEXING { list, index }
            : list
        }

compose
    = hd:taggedAtom tl:(_ composeOp __ taggedAtom)* {
        if (tl.length > 0)
            return #COMPOSE { functions: hd::tl }
        else
            return hd
    }

/************* ATOMS *************/

taggedAtom
    = tag:tag value:(__ v:taggedAtom => v)?
        => #TAGGED_VALUE { tag, value }
    / atom

atom
    = operatorFun
    / tuple
    / recValue
    / list
    / set
    / dictValue
    / float
    / string
    / specializedType
    / lambda
    / voidValue
    / boolean

operatorFun
    = "(" op:overridableOp ")"
        => #VALUE_BY_NAME { op }

voidValue
    = void => #VOID_VALUE {}
    / "<>" => #EMPTY_LINKED_LIST {}

implicitParam
    = "$" [a-z]
        => #IMPLICIT_PARAM { name: text() }
    / "$" => error("Expecting letter for implicit parameter after \"$\"")

tuple
    = "(" __ hd:branch tl:(_ "," __ v:branch => v)* close:")"? {
        if (!close) {
            if (tl.length > 0)
                error("Expecting \")\" to close the tuple")
            else
                error("Expecting matching \")\"")
        }
        return tl.length > 0
            ? #TUPLE { values: hd::tl }
            : hd
        }

recValue
    = "{|" __ members:recMembers? close:(__  "|}")? {
        if (!close) error("Expecting \"|\x7d\" to close the record")
        return #REC_VALUE { members: members ?? [] }
    }
recMembers
    = hd:recMemberValue tl:(_ ("," / eol) __ m:recMemberValue => m)*
recMemberValue
    = recMemberFieldValue
    / propDef
    / fun
    / splat
recMemberFieldValue
    = modifier:(m:recMemberFieldValueModifier _)? name:id _ type:type? _ colon __ value:branch
        => #REC_MEMBER_VALUE { modifier, name, type, value }
recMemberFieldValueModifier
    = "const" / "var"

splat
    = "..." value:valueByName
        => #SPLAT { value }

list = "[" _ elements:listElements? close:(_ "]")? {
        if (!close) error("Expecting \"]\" to close the list")
        return #LIST { values: elements ?? [] }
    }
listElements
    = __ hd:(splat / branch) tl:(_ "," __ v:(splat / branch) => v)* __
        => hd::tl

set = "set" _ "{" _ elements:setElements? close:(_ "}")? {
        if (!close) error("Expecting \"\x7d\" to close the set")
        return #SET { values: elements ?? [] }
    }
setElements
    = __ hd:(splat / branch) tl:(_ "," __ v:(splat / branch) => v)* __
        => hd::tl

dictValue
    = "dict" _ "{" _ elements:dictElements? _ close:"}"? {
        if (!close) error("Expecting \"\x7d\" to close the dictionary")
        return #DICT_VALUE { elements: elements ?? [] }
    }
dictElements
    = __ hd:dictKeyValue tl:(_ "," __ m:dictKeyValue => m)* __
        => hd::tl
dictKeyValue
    = key:valueExpr _ "->" __ value:branch
        => #DICT_KEY_VALUE { key, value }
    / splat

specializedType
    = member:getMember params:specializeParams? {
        if (params)
            return #SPECIALIZE_TYPE { base: member, params }
        else
            return member
    }

specializeParams
    = _ "of" __ hd:valueByName tl:(_ "/" __ i:valueByName => i)*
        => hd::tl

getMember
    = container:(valueByName / implicitParam / "me")
    path:("." id:id => id)* {
        if (path.length > 0)
            return #GET_MEMBER { container, path }
        else
            return container
    }
    / path:("." id:id => id)+ {
        return #GET_WISE_MEMBER { path }
    }

valueByName
    = hd:id tl:("--" id:id => id)* {
        let ids = hd::tl
        const name = ids.pop()
        return #VALUE_BY_NAME { name, namespace: ids }
    }
    / "me"

boolean
    = value:("yes" / "no")
        => #BOOLEAN { value: value === "yes" }

/************* TOKENS *************/

identifiers
    = hd:id tl:(_ "/" __ id:id => id)*
        => hd::tl

id = $(!keyword "_"? [A-Za-z] [A-Za-z0-9_]*)

tag
    = $("#" "_"? [A-Za-z] [A-Za-z0-9_]*)

integer = [0-9] [0-9_]* ([eE] "+"? [0-9]+)?
    => #INTEGER { value: BigInt(text()) }

float = beforePoint:$([0-9] [0-9_]*) afterPoint:$("." [0-9] [0-9_]*)? expPart:$([eE] [+-]? [0-9]+)? {
        if (afterPoint || expPart && expPart.includes("-") )
            return #FLOAT { value: parseFloat(text()) }
        else
        {
            if (expPart)
            {
                const expValue = expPart.substring(1)
                const factor = BigInt(10) ** BigInt(expValue)
                return #INTEGER { value: BigInt(beforePoint) * factor }
            }
            else
                return #INTEGER { value: BigInt(text()) }
        }
    }

void = "()"

_ = [ \t]*
__ = ([ \t\r\n] / comment)*
comment
    = "//" [^\r\n]*
    / "/*" (!"*/" .)* "*/"
eol = ([ \t] / comment)* "\r"? "\n" __

keyword = ("let" / "var" / "fun" / "sub" / "mut" / "do" / "end" / "return" / "yield" / "state"
    / "new" / "const" / "init" / "base" / "prop" / "me" / "with"
    / "type" / "of" / "any" / "enum" / "set" / "dict" / "yes" / "no" / "record"
    / "wise" / "else" / "while" / "iter" / "next" / "break" / "case" / "other" / "when" / "resume"
    / "in" / "or" / "xor" / "global" / "async" / "defer") ![A-Za-z0-9_]

assignmentOp = ":=" / "*=" / "/=" / "%=" / "+=" / "-=" / "++="
colon = $(":" ![=:])

pipe = $("|" !"}")
logicOp = "or" / "xor" / $("&" !"=")
comparisonOp = $("=" !">") / "!=" / $(">" ![>=<]) / ">=" / $("<" ![>|]) / "<=" / "in";
concatOp = $("++" !"=")
additiveOp = $(("+" / "-") !([=>] / ".."))
multiplicativeOp = $(("*" / "/" / "%") !"=")
notOp = $("!" !"=")
powerOp = $("^" !"=")
composeOp = $(">>" !"=")
setComparisonOp = "{=}" / "{!=}" / "{<}" / "{<=}" / "{>}" / "{>=}"
setOp = "{-}" / "{+}" / "{&}" / "{*}" / "{^}"
tildeOp = "~" // unused
rangeOp = "..<" / "..=" / "..>=" / "..>" / "+.." / "-.."
overridableOp
    = logicOp
    / comparisonOp
    / concatOp
    / additiveOp
    / multiplicativeOp
    / notOp
    / powerOp
    / composeOp
    / setComparisonOp
    / setOp
    / rangeOp

string = "\"" parts:(literalPart / formattedValue)*  "\""
    => #STRING_VALUE { parts }

literalPart = chars:literalChar+
    => #STRING_PART { value: chars.join("") }
formattedValue
    = "{" _ value:branch _ "}"
    => #FORMATTED_VALUE { value }
literalChar
    = [^"{}]
    / "{{" => "\x7b"
    / "}}" => "\x7d"
    / "\"\"" => "\""
